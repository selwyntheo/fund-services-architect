import json
import logging
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
from pymongo import MongoClient
from pymongo.errors import PyMongoError, ConnectionFailure, OperationFailure
from bson import ObjectId, json_util
import traceback

class MongoQueryTool:
    """
    A tool for executing MongoDB queries generated by the intent recognition system.
    Handles the 6 financial collections: dataNav, dataLedger, dataSubLedgerPosition, 
    dataSubLedgerTransaction, genericReconResult, dataIntegrityViolations
    """
    
    ALLOWED_COLLECTIONS = {
        'dataNav',
        'dataLedger', 
        'dataSubLedgerPosition',
        'dataSubLedgerTransaction',
        'genericReconResult',
        'dataIntegrityViolations'
    }
    
    def __init__(self, connection_string: str, database_name: str, timeout_ms: int = 30000):
        """
        Initialize the MongoDB connection
        
        Args:
            connection_string: MongoDB connection URI
            database_name: Name of the database
            timeout_ms: Query timeout in milliseconds
        """
        self.connection_string = connection_string
        self.database_name = database_name
        self.timeout_ms = timeout_ms
        self.client = None
        self.db = None
        self._setup_logging()
        
    def _setup_logging(self):
        """Setup logging for query execution tracking"""
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
    def connect(self) -> bool:
        """
        Establish connection to MongoDB
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self.client = MongoClient(
                self.connection_string,
                serverSelectionTimeoutMS=self.timeout_ms,
                socketTimeoutMS=self.timeout_ms
            )
            # Test connection
            self.client.admin.command('ping')
            self.db = self.client[self.database_name]
            self.logger.info(f"Connected to MongoDB database: {self.database_name}")
            return True
        except ConnectionFailure as e:
            self.logger.error(f"Failed to connect to MongoDB: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error during connection: {e}")
            return False
    
    def disconnect(self):
        """Close MongoDB connection"""
        if self.client:
            self.client.close()
            self.logger.info("MongoDB connection closed")
    
    def execute_query(
        self, 
        collection_name: str, 
        query_type: str, 
        query: Dict[str, Any],
        projection: Optional[Dict[str, Any]] = None,
        sort: Optional[List[tuple]] = None,
        limit: Optional[int] = None,
        skip: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Execute MongoDB query generated by the intent recognition system
        
        Args:
            collection_name: Name of the collection (must be in ALLOWED_COLLECTIONS)
            query_type: Type of query ('find', 'aggregate', 'count', 'distinct')
            query: The MongoDB query/pipeline
            projection: Fields to include/exclude (for find queries)
            sort: Sort specification as list of (field, direction) tuples
            limit: Maximum number of documents to return
            skip: Number of documents to skip
            
        Returns:
            Dict containing query results, metadata, and execution info
        """
        
        if not self.client or not self.db:
            return self._error_response("No database connection. Call connect() first.")
        
        # Validate collection name
        if collection_name not in self.ALLOWED_COLLECTIONS:
            return self._error_response(
                f"Invalid collection '{collection_name}'. "
                f"Allowed collections: {', '.join(self.ALLOWED_COLLECTIONS)}"
            )
        
        collection = self.db[collection_name]
        start_time = datetime.now()
        
        try:
            result = self._execute_by_type(
                collection, query_type, query, projection, sort, limit, skip
            )
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return {
                'success': True,
                'collection': collection_name,
                'query_type': query_type,
                'execution_time_seconds': execution_time,
                'query': query,
                'result': result,
                'timestamp': datetime.now().isoformat()
            }
            
        except OperationFailure as e:
            self.logger.error(f"MongoDB operation failed: {e}")
            return self._error_response(f"Query execution failed: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error during query execution: {e}")
            self.logger.error(traceback.format_exc())
            return self._error_response(f"Unexpected error: {e}")
    
    def _execute_by_type(
        self, 
        collection, 
        query_type: str, 
        query: Dict[str, Any],
        projection: Optional[Dict[str, Any]],
        sort: Optional[List[tuple]],
        limit: Optional[int],
        skip: Optional[int]
    ) -> Dict[str, Any]:
        """Execute query based on type"""
        
        query_type = query_type.lower()
        
        if query_type == 'find':
            return self._execute_find(collection, query, projection, sort, limit, skip)
        elif query_type == 'aggregate':
            return self._execute_aggregate(collection, query)
        elif query_type == 'count':
            return self._execute_count(collection, query)
        elif query_type == 'distinct':
            return self._execute_distinct(collection, query)
        else:
            raise ValueError(f"Unsupported query type: {query_type}")
    
    def _execute_find(
        self, 
        collection, 
        query: Dict[str, Any],
        projection: Optional[Dict[str, Any]],
        sort: Optional[List[tuple]],
        limit: Optional[int],
        skip: Optional[int]
    ) -> Dict[str, Any]:
        """Execute find query"""
        
        cursor = collection.find(query, projection)
        
        if sort:
            cursor = cursor.sort(sort)
        if skip:
            cursor = cursor.skip(skip)
        if limit:
            cursor = cursor.limit(limit)
        
        documents = list(cursor)
        
        return {
            'documents': json.loads(json_util.dumps(documents)),
            'count': len(documents),
            'has_more': len(documents) == limit if limit else False
        }
    
    def _execute_aggregate(self, collection, pipeline: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Execute aggregation pipeline"""
        
        cursor = collection.aggregate(pipeline)
        documents = list(cursor)
        
        return {
            'documents': json.loads(json_util.dumps(documents)),
            'count': len(documents)
        }
    
    def _execute_count(self, collection, query: Dict[str, Any]) -> Dict[str, Any]:
        """Execute count query"""
        
        count = collection.count_documents(query)
        
        return {
            'count': count
        }
    
    def _execute_distinct(self, collection, query: Dict[str, Any]) -> Dict[str, Any]:
        """Execute distinct query"""
        
        field = query.get('field')
        filter_query = query.get('filter', {})
        
        if not field:
            raise ValueError("Distinct query requires 'field' parameter")
        
        values = collection.distinct(field, filter_query)
        
        return {
            'distinct_values': json.loads(json_util.dumps(values)),
            'count': len(values)
        }
    
    def _error_response(self, message: str) -> Dict[str, Any]:
        """Generate standardized error response"""
        return {
            'success': False,
            'error': message,
            'timestamp': datetime.now().isoformat()
        }
    
    def get_collection_stats(self, collection_name: str) -> Dict[str, Any]:
        """
        Get basic statistics about a collection
        
        Args:
            collection_name: Name of the collection
            
        Returns:
            Dict containing collection statistics
        """
        
        if collection_name not in self.ALLOWED_COLLECTIONS:
            return self._error_response(f"Invalid collection '{collection_name}'")
        
        if not self.client or not self.db:
            return self._error_response("No database connection")
        
        try:
            collection = self.db[collection_name]
            
            # Get basic stats
            stats = self.db.command('collStats', collection_name)
            document_count = collection.count_documents({})
            
            # Sample document for schema understanding
            sample_doc = collection.find_one()
            
            return {
                'success': True,
                'collection': collection_name,
                'document_count': document_count,
                'size_bytes': stats.get('size', 0),
                'avg_obj_size': stats.get('avgObjSize', 0),
                'indexes': len(stats.get('indexSizes', {})),
                'sample_document': json.loads(json_util.dumps(sample_doc)) if sample_doc else None,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return self._error_response(f"Failed to get collection stats: {e}")


def execute_mongo_query(
    connection_string: str,
    database_name: str,
    collection_name: str,
    query_type: str,
    query: Union[Dict, List],
    projection: Optional[Dict] = None,
    sort: Optional[List[tuple]] = None,
    limit: Optional[int] = 100,
    skip: Optional[int] = None
) -> Dict[str, Any]:
    """
    Convenience function to execute a MongoDB query
    
    This function serves as the main tool interface for the AI agent
    
    Args:
        connection_string: MongoDB connection URI
        database_name: Database name
        collection_name: Collection name (must be one of the 6 allowed)
        query_type: 'find', 'aggregate', 'count', or 'distinct'
        query: MongoDB query dict or aggregation pipeline list
        projection: Fields to include/exclude (find only)
        sort: Sort specification
        limit: Max documents to return (default 100 for safety)
        skip: Documents to skip
        
    Returns:
        Dict with query results and metadata
        
    Example Usage:
        # Simple find query
        result = execute_mongo_query(
            connection_string="mongodb://localhost:27017",
            database_name="financial_db",
            collection_name="dataLedger",
            query_type="find",
            query={"status": "PENDING", "amount": {"$gt": 1000}},
            limit=50
        )
        
        # Aggregation query
        result = execute_mongo_query(
            connection_string="mongodb://localhost:27017",
            database_name="financial_db", 
            collection_name="genericReconResult",
            query_type="aggregate",
            query=[
                {"$match": {"reconciliationStatus": "FAILED"}},
                {"$group": {"_id": "$errorType", "count": {"$sum": 1}}}
            ]
        )
    """
    
    tool = MongoQueryTool(connection_string, database_name)
    
    try:
        if not tool.connect():
            return tool._error_response("Failed to connect to MongoDB")
        
        # Convert query for aggregation if needed
        if query_type.lower() == 'aggregate' and isinstance(query, list):
            result = tool.execute_query(
                collection_name=collection_name,
                query_type=query_type,
                query=query  # Pipeline as list
            )
        else:
            result = tool.execute_query(
                collection_name=collection_name,
                query_type=query_type,
                query=query,
                projection=projection,
                sort=sort,
                limit=limit,
                skip=skip
            )
        
        return result
        
    finally:
        tool.disconnect()


# Example usage and testing
if __name__ == "__main__":
    # Example usage
    
    # Configuration
    CONNECTION_STRING = "mongodb://localhost:27017"
    DATABASE_NAME = "financial_db"
    
    # Test simple find query
    result1 = execute_mongo_query(
        connection_string=CONNECTION_STRING,
        database_name=DATABASE_NAME,
        collection_name="dataLedger",
        query_type="find",
        query={"status": "PENDING"},
        limit=10
    )
    
    print("Find Query Result:")
    print(json.dumps(result1, indent=2))
    
    # Test aggregation query
    result2 = execute_mongo_query(
        connection_string=CONNECTION_STRING,
        database_name=DATABASE_NAME,
        collection_name="genericReconResult",
        query_type="aggregate",
        query=[
            {"$match": {"reconciliationStatus": "FAILED"}},
            {"$group": {"_id": "$errorType", "count": {"$sum": 1}}},
            {"$sort": {"count": -1}}
        ]
    )
    
    print("\nAggregation Query Result:")
    print(json.dumps(result2, indent=2))
